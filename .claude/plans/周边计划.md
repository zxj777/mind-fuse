# 周边系统实现计划：Rust Realtime Server + Go API

## 概述

将原 plan.md 中的 "Go 全栈后端" 架构调整为 **Go API + Rust Realtime** 双服务架构。Rust 提前在 MVP 阶段承担 WebSocket 网关 + Presence + Yjs 转发职责，为 Phase 2 自研 CRDT 打基础。

---

## 架构对比

### 原方案 (plan.md)
```
客户端 ←→ Go API (HTTP + WebSocket + Yjs + Presence)
```

### 新方案
```
客户端 ←HTTP→ Go API (Auth/CRUD)
客户端 ←WS→ Rust Realtime (WebSocket + Yjs + Presence)
                    ↓
              Dragonfly (Presence缓存 + Pub/Sub)
                    ↓
              Go API (权限验证 gRPC)
```

---

## 系统边界

| 系统 | 语言 | 职责 |
|------|------|------|
| **Go API** | Go | Auth (OAuth/JWT)、Workspace/Board CRUD、权限管理、邀请系统 |
| **Rust Realtime** | Rust | WebSocket 网关、Yjs 同步转发、Presence 广播、连接认证 |
| **Dragonfly** | - | Presence 状态缓存、跨实例 Pub/Sub |
| **PostgreSQL** | - | 持久化数据 (users, workspaces, boards, members) |

---

## 实现计划

### Week 1: Go API - Auth 系统

**目标**: 完成用户登录注册，生成 JWT

**文件结构**:
```
apps/api-go/
├── cmd/server/main.go
├── internal/
│   ├── auth/
│   │   ├── handler.go      # OAuth回调、登出
│   │   ├── jwt.go          # JWT生成/验证
│   │   └── middleware.go   # 认证中间件
│   ├── db/
│   │   ├── queries/        # sqlc SQL文件
│   │   └── sqlc.yaml
│   └── config/
│       └── config.go
├── go.mod
└── go.sum
```

**数据表**:
```sql
-- migrations/001_auth.sql
CREATE TABLE users (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email         VARCHAR(255) UNIQUE NOT NULL,
  name          VARCHAR(255),
  avatar_url    TEXT,
  oauth_provider VARCHAR(50),
  oauth_id      VARCHAR(255),
  created_at    TIMESTAMPTZ DEFAULT NOW(),
  updated_at    TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE sessions (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id     UUID REFERENCES users(id) ON DELETE CASCADE,
  token       VARCHAR(512) UNIQUE NOT NULL,
  expires_at  TIMESTAMPTZ NOT NULL,
  created_at  TIMESTAMPTZ DEFAULT NOW()
);
```

**API**:
- `GET /api/auth/google` → 重定向 Google OAuth
- `GET /api/auth/google/callback` → 创建 user + session，返回 JWT
- `POST /api/auth/logout` → 删除 session
- `GET /api/auth/me` → 获取当前用户

**验证**:
- curl 测试 OAuth 流程
- 验证 JWT 生成和解析

---

### Week 2: Go API - Workspace/Board CRUD

**目标**: 完成工作空间和白板的增删改查

**新增数据表**:
```sql
-- migrations/002_workspace.sql
CREATE TABLE workspaces (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name        VARCHAR(255) NOT NULL,
  type        VARCHAR(50) NOT NULL CHECK (type IN ('personal', 'team')),
  owner_id    UUID REFERENCES users(id),
  created_at  TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE workspace_members (
  workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
  user_id      UUID REFERENCES users(id) ON DELETE CASCADE,
  role         VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'admin', 'member')),
  joined_at    TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (workspace_id, user_id)
);

-- migrations/003_board.sql
CREATE TABLE boards (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID REFERENCES workspaces(id) ON DELETE CASCADE,
  name          VARCHAR(255) NOT NULL,
  thumbnail_url TEXT,
  created_by    UUID REFERENCES users(id),
  created_at    TIMESTAMPTZ DEFAULT NOW(),
  updated_at    TIMESTAMPTZ DEFAULT NOW(),
  deleted_at    TIMESTAMPTZ
);

CREATE TABLE board_members (
  board_id   UUID REFERENCES boards(id) ON DELETE CASCADE,
  user_id    UUID REFERENCES users(id) ON DELETE CASCADE,
  role       VARCHAR(50) NOT NULL CHECK (role IN ('owner', 'editor', 'viewer')),
  invited_by UUID REFERENCES users(id),
  joined_at  TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (board_id, user_id)
);

CREATE TABLE board_invites (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  board_id   UUID REFERENCES boards(id) ON DELETE CASCADE,
  token      VARCHAR(255) UNIQUE NOT NULL,
  role       VARCHAR(50) NOT NULL,
  expires_at TIMESTAMPTZ,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**新增文件**:
```
internal/
├── workspace/
│   ├── handler.go
│   ├── service.go
│   └── repository.go
├── board/
│   ├── handler.go
│   ├── service.go
│   └── repository.go
└── invite/
    ├── handler.go
    └── service.go
```

**API**:
- `GET /api/workspaces` → 列出用户的 workspace
- `POST /api/workspaces` → 创建 team workspace
- `GET /api/workspaces/:id/boards` → 列出 boards
- `POST /api/workspaces/:id/boards` → 创建 board
- `GET /api/boards/:id` → 获取 board 详情
- `DELETE /api/boards/:id` → 软删除
- `POST /api/boards/:id/invite` → 生成邀请链接
- `POST /api/invites/:token/accept` → 接受邀请

**验证**:
- 用户注册后自动创建 personal workspace
- 创建 board 后自动添加为 owner
- 邀请链接可正常接受

---

### Week 3: Rust Realtime Server - 基础框架

**目标**: 搭建 Rust WebSocket 服务，实现连接管理

**文件结构**:
```
apps/realtime-server/
├── Cargo.toml
├── src/
│   ├── main.rs
│   ├── config.rs
│   ├── server.rs           # axum HTTP/WS 服务
│   ├── ws/
│   │   ├── mod.rs
│   │   ├── handler.rs      # WebSocket 升级处理
│   │   ├── connection.rs   # 单个连接管理
│   │   └── room.rs         # Board room 管理
│   ├── auth/
│   │   ├── mod.rs
│   │   └── jwt.rs          # JWT 验证
│   └── error.rs
```

**依赖**:
```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
axum = { version = "0.7", features = ["ws"] }
tower-http = { version = "0.5", features = ["cors", "trace"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
jsonwebtoken = "9"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1", features = ["v4", "serde"] }
```

**核心逻辑**:
```rust
// src/ws/handler.rs
pub async fn ws_handler(
    ws: WebSocketUpgrade,
    Query(params): Query<WsParams>,  // token, boardId
    State(state): State<AppState>,
) -> impl IntoResponse {
    // 1. 验证 JWT
    // 2. 检查 board 权限 (调用 Go API 或查 Redis 缓存)
    // 3. 升级 WebSocket
    // 4. 加入 room
}
```

**验证**:
- WebSocket 连接成功建立
- 无效 JWT 被拒绝
- 日志正常输出

---

### Week 4: Rust Realtime - Yjs 转发 + Presence

**目标**: 实现 Yjs 消息转发和 Presence 广播

**新增文件**:
```
src/
├── yjs/
│   ├── mod.rs
│   └── sync.rs             # Yjs 二进制消息转发
├── presence/
│   ├── mod.rs
│   ├── state.rs            # Presence 状态结构
│   └── broadcast.rs        # 广播逻辑
└── redis/
    ├── mod.rs
    └── client.rs           # Dragonfly 连接
```

**消息协议**:
```rust
#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
enum ClientMessage {
    // Yjs 同步
    #[serde(rename = "yjs:sync")]
    YjsSync { data: Vec<u8> },

    // Presence
    #[serde(rename = "presence:update")]
    PresenceUpdate { cursor: Option<Cursor>, selection: Vec<String> },

    #[serde(rename = "presence:viewport")]
    PresenceViewport { x: f64, y: f64, zoom: f64 },
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "type")]
enum ServerMessage {
    #[serde(rename = "yjs:sync")]
    YjsSync { data: Vec<u8> },

    #[serde(rename = "presence:sync")]
    PresenceSync { user_id: String, cursor: Option<Cursor>, selection: Vec<String> },

    #[serde(rename = "presence:join")]
    PresenceJoin { user_id: String, user: UserInfo },

    #[serde(rename = "presence:leave")]
    PresenceLeave { user_id: String },
}
```

**Dragonfly 数据结构**:
```
board:{boardId}:presence → Hash {
  {userId}: JSON { cursor, selection, viewport, lastSeen }
}
board:{boardId}:connections → Set { connectionId1, connectionId2, ... }
```

**验证**:
- 两个客户端连接同一 board
- Yjs 消息正确转发
- Presence 更新正确广播
- 断开连接后 presence:leave 正确发送

---

### Week 5: 集成测试 + 权限系统

**目标**: Go 和 Rust 服务联调，完善权限检查

**Go API 新增**:
```go
// internal/board/grpc.go - 供 Rust 调用
type BoardPermissionService interface {
    CheckPermission(ctx context.Context, userID, boardID string) (Role, error)
}
```

**或使用 HTTP 内部 API**:
```
GET /internal/boards/:id/permission?userId=xxx
Authorization: Internal-Secret xxx
```

**Rust 调用**:
```rust
// src/auth/permission.rs
pub async fn check_board_permission(
    client: &reqwest::Client,
    user_id: &str,
    board_id: &str,
) -> Result<Role, Error> {
    // 1. 先查 Redis 缓存
    // 2. 缓存未命中则调用 Go API
    // 3. 缓存结果 (TTL 5分钟)
}
```

**端到端测试场景**:
1. 用户登录 → 创建 workspace → 创建 board → WebSocket 连接 → 编辑
2. 邀请另一用户 → 被邀请者登录 → 接受邀请 → WebSocket 连接 → 协作
3. Viewer 角色尝试编辑 → 被拒绝
4. 未登录用户 → WebSocket 连接失败

---

### Week 6: 监控 + 部署配置

**目标**: 基础监控和 Docker 部署

**Go API 监控**:
```go
// 健康检查
GET /health → { "status": "ok", "db": "ok", "redis": "ok" }

// Prometheus metrics (可选)
GET /metrics
```

**Rust Realtime 监控**:
```rust
// 健康检查
GET /health → { "status": "ok", "connections": 42, "rooms": 5 }

// 指标
- 活跃连接数
- 消息吞吐量
- 错误率
```

**Docker Compose**:
```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: mindfuse
      POSTGRES_USER: mindfuse
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  dragonfly:
    image: docker.dragonflydb.io/dragonflydb/dragonfly
    ports:
      - "6379:6379"

  api:
    build:
      context: ./apps/api-go
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgres://mindfuse:${DB_PASSWORD}@postgres:5432/mindfuse
      REDIS_URL: redis://dragonfly:6379
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "8080:8080"
    depends_on:
      - postgres
      - dragonfly

  realtime:
    build:
      context: ./apps/realtime-server
      dockerfile: Dockerfile
    environment:
      REDIS_URL: redis://dragonfly:6379
      JWT_SECRET: ${JWT_SECRET}
      GO_API_URL: http://api:8080
    ports:
      - "8081:8081"
    depends_on:
      - dragonfly
      - api

volumes:
  postgres_data:
```

---

## 关键文件清单

### Go API (`apps/api-go/`)
| 文件 | 用途 |
|------|------|
| `cmd/server/main.go` | 入口 |
| `internal/auth/handler.go` | OAuth 处理 |
| `internal/auth/jwt.go` | JWT 工具 |
| `internal/workspace/handler.go` | Workspace API |
| `internal/board/handler.go` | Board API |
| `internal/board/permission.go` | 权限检查 |
| `internal/db/queries/*.sql` | sqlc SQL |
| `internal/config/config.go` | 配置管理 |

### Rust Realtime (`apps/realtime-server/`)
| 文件 | 用途 |
|------|------|
| `src/main.rs` | 入口 |
| `src/server.rs` | axum 服务 |
| `src/ws/handler.rs` | WebSocket 升级 |
| `src/ws/connection.rs` | 连接管理 |
| `src/ws/room.rs` | Room 管理 |
| `src/yjs/sync.rs` | Yjs 消息转发 |
| `src/presence/state.rs` | Presence 状态 |
| `src/presence/broadcast.rs` | Presence 广播 |
| `src/auth/jwt.rs` | JWT 验证 |
| `src/redis/client.rs` | Dragonfly 客户端 |

---

## 验证清单

### 功能验证
- [ ] Google OAuth 登录成功
- [ ] JWT 生成和验证正确
- [ ] 用户注册后自动创建 personal workspace
- [ ] Workspace/Board CRUD 正常
- [ ] 邀请链接生成和接受正常
- [ ] WebSocket 连接建立成功
- [ ] Yjs 消息正确转发给同 room 用户
- [ ] Presence 更新正确广播
- [ ] 权限检查正确（viewer 不能编辑）
- [ ] 断开连接后 presence:leave 正确广播

### 性能验证
- [ ] 单 Rust 实例支持 1000+ 并发连接
- [ ] Presence 广播延迟 < 50ms
- [ ] Yjs 消息转发延迟 < 20ms

### 部署验证
- [ ] Docker Compose 一键启动
- [ ] 健康检查端点正常
- [ ] 日志输出正确

---

## 与 plan.md 的关系

| 方面 | plan.md | 本计划 |
|------|---------|--------|
| 后端架构 | Go 全栈 | Go API + Rust Realtime |
| WebSocket | Go (nhooyr.io/websocket) | Rust (axum + tokio-tungstenite) |
| Presence | Go 实现 | Rust 实现 |
| Phase 2 CRDT | 从零开始 Rust 服务 | 在现有 Rust Realtime 上扩展 |

**优势**:
1. Rust 服务从 MVP 就有真实流量，不是 Phase 2 才冷启动
2. WebSocket + Presence + CRDT 同一个服务，减少网络跳转
3. 为 Phase 2 自研 CRDT 提供现成的框架
4. Go 专注业务逻辑，Rust 专注实时性能

---

## 下一步

完成本计划后，继续 plan.md 中的：
- Week 3-4: 渲染引擎 (PixiJS)
- Week 5-6: 内容生成 Agent
- Week 7-8: 编辑器核心
