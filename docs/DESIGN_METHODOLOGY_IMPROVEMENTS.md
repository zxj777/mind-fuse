# DESIGN_METHODOLOGY.md 进一步改进清单

> 本文档记录了设计方法论的待完善项，按优先级排序
>
> 最后更新：2025-12-23

## 已完成的补充 ✅

- ✅ **阶段 2.5：冲突解决模型** - 完整的协作冲突处理策略
- ✅ **阶段 4：错误分类与处理策略** - 四类错误的统一模型
- ✅ **Step 8：测试策略** - 三层测试金字塔和性能基准

---

## 🔴 高优先级改进（影响系统核心）

### 1. 增加"反模式"（Anti-Patterns）章节

**目标**：在每个阶段后，增加 ❌ "常见陷阱" 小节

**影响**：帮助开发者避免典型错误，减少返工

**实施位置**：

- 阶段 1（领域建模）后
- 阶段 3（状态机设计）后
- 阶段 5（序列化设计）后
- 阶段 6（性能与索引）后

**示例格式**：

```markdown
### 阶段 1 常见陷阱

❌ **陷阱 1：用对象引用代替 ID**
错误示例：
\```typescript
interface Group {
  members: Shape[]  // ❌ 直接引用对象
}
\```

为什么错：
- 循环引用导致 JSON.stringify 失败
- 无法表示"引用不存在"的状态
- 难以实现 Undo/Redo

正确做法：
\```typescript
interface Group {
  memberIds: Set<ShapeId>  // ✅ 用 ID 引用
}
\```

❌ **陷阱 2：把临时状态放进 Document**
错误示例：
\```typescript
interface Document {
  shapes: Map<ShapeId, Shape>
  isDragging: boolean  // ❌ UI 状态
  currentTool: Tool     // ❌ 不应序列化
}
\```

为什么错：
- 序列化时带上了无意义的状态
- 多用户协作时会互相干扰

正确做法：用单独的 `EditorState` 管理 UI 状态
```

**需要补充的陷阱**：

#### 阶段 1 陷阱：
- 用对象引用代替 ID
- 把临时状态放进持久化结构
- 设计 N:M 关系时没有中间表
- 忘记标注级联删除规则

#### 阶段 3 陷阱：
- 状态转换没有不变量检查
- 允许非法状态转换（应抛出错误）
- 状态机太复杂（超过 7 个状态）

#### 阶段 5 陷阱：
- 用 `undefined` 代替 `null`（会被 JSON 删除）
- Map/Set 忘记显式转换
- 没有 `schemaVersion` 字段

#### 阶段 6 陷阱：
- 过早优化（还没测量就加索引）
- 忘记索引的维护成本
- 索引和数据不同步

---

### 2. 增加"检查清单"（Checklist）汇总

**目标**：在文档末尾汇总所有 `[ ]` 检查清单，方便评审

**影响**：确保设计评审时不遗漏关键检查点

**位置**：在"附录"章节之前，新增一个独立章节

**格式**：

```markdown
## 设计评审完整检查清单

使用这个清单在设计评审时逐项检查，确保没有遗漏。

### 阶段 1：领域建模 ✅

- [ ] 每个实体都有唯一 ID？
- [ ] 引用关系清晰标注（实线 vs 虚线）？
- [ ] 级联删除规则已定义？
- [ ] 没有循环引用对象？
- [ ] 没有悬空引用？

### 阶段 2：数据流设计 ✅

- [ ] 每个步骤标注了时间复杂度？
- [ ] 失败点已标注？
- [ ] 10,000 shapes 时仍在 16ms 内？
- [ ] 网络断开的恢复策略已定义？

### 阶段 2.5：冲突解决 ⚠️

- [ ] 每种属性类型的冲突策略已定义？
- [ ] 时间戳方案已选定（LWW/HLC/Vector Clock）？
- [ ] 有单元测试验证合并逻辑？
- [ ] 用户可见的冲突提示已设计？
- [ ] 删除 vs 修改的冲突规则已明确？

### 阶段 3：状态机设计 ✅

- [ ] 每个状态的不变量已定义？
- [ ] 非法状态转换会抛出错误？
- [ ] 状态是显式还是推导？已明确？

### 阶段 4：类型架构 ✅

- [ ] 依赖是单向的（无循环依赖）？
- [ ] 验证逻辑在独立 Validator？
- [ ] 操作函数在命名空间（非类方法）？
- [ ] 错误处理策略已明确（throw vs Result）？
- [ ] 用户错误信息是否友好？

### 阶段 5：序列化设计 ✅

- [ ] Map/Set 有显式转换？
- [ ] undefined 已替换为 null？
- [ ] 有 schemaVersion 和 documentVersion 字段？
- [ ] 支持版本迁移（v1→v2→v3...）？
- [ ] 确定性序列化（同一状态→同一 JSON）？
- [ ] 序列化往返测试通过？

### 阶段 6：性能与索引 ✅

- [ ] 热路径查询已识别？（每帧执行的）
- [ ] 必需索引已实现？（spatialIndex, groupMembersIndex）
- [ ] 索引维护策略已定义？
- [ ] 性能基准测试已编写？
- [ ] 10,000→100,000 shapes 时的扩展策略已考虑？

### Step 8：测试策略 ⚠️

- [ ] 单元测试覆盖率 > 80%？
- [ ] 所有边缘情况有测试？（空输入、极端值、并发）
- [ ] 有冲突场景的测试？
- [ ] 有性能回归测试？
- [ ] CI 自动运行测试？
- [ ] 测试失败时阻止合并？

### 协作与一致性 ⚠️

- [ ] 持久态/临时态/派生态已明确分类？
- [ ] 写入模型已选定（Command/Patch/Event）？
- [ ] 一致性级别已选定（Strong/Lenient/Tolerant）？
- [ ] 引用完整性的修复策略已定义？
- [ ] Map/Set 序列化时固定排序？
- [ ] Undo/Redo 的基本单位已明确？
- [ ] 可观测性：每个变更有 opId/actorId/timestamp？
```

**估计工作量**：1-2 小时（汇总 + 格式化）

---

### 3. 增加"架构决策记录"（ADR）模板和示例

**目标**：提供标准的 ADR 模板，用于记录重大架构决策

**影响**：确保团队能追溯"为什么这样设计"

**位置**：附录中增加"ADR 模板与示例"

**内容**：

```markdown
### 架构决策记录（ADR）模板

当团队做出重大架构决策时，使用此模板记录。

#### ADR 编号规则

- `ADR-001` 到 `ADR-099`：基础架构决策（数据结构、模块划分）
- `ADR-100` 到 `ADR-199`：性能相关决策
- `ADR-200` 到 `ADR-299`：协作与同步相关决策
- `ADR-300` 到 `ADR-399`：安全与权限相关决策

#### 模板

```
# ADR-XXX: [决策标题]

**日期**：YYYY-MM-DD
**状态**：[提议中 / 已采纳 / 已废弃 / 已被 ADR-YYY 取代]
**决策者**：@username
**相关人员**：@user1, @user2

## 背景

[描述需要做决策的上下文和问题]

## 决策

[描述你的决策]

## 考虑的选项

### 选项 1：[名称]
- **优点**：
  - ...
- **缺点**：
  - ...
- **成本**：开发工时、性能影响、维护成本

### 选项 2：[名称]
- **优点**：
  - ...
- **缺点**：
  - ...

## 决策理由

[为什么选择这个方案]

## 后果

- ✅ 积极后果：
  - ...
- ❌ 消极后果：
  - ...
- ⚠️ 风险：
  - ...

## 合规性

如何验证这个决策被正确执行？
- [ ] 代码审查检查点
- [ ] 单元测试覆盖
- [ ] 性能基准达标

## 相关文档

- 设计文档：链接
- 实现 PR：链接
- 相关 ADR：ADR-XXX
```

#### 示例 ADR

##### ADR-001: 使用 Map 而非 Array 存储 Shapes

**日期**：2025-12-23
**状态**：已采纳
**决策者**：@core-team

**背景**：
Document 需要存储 10,000+ shapes，需要频繁的 O(1) ID 查找。目前有三种选项。

**决策**：
选择 `Map<ShapeId, Shape>`

**考虑的选项**：

1. **`shapes: Shape[]`**
   - 优点：简单，JSON 序列化直接
   - 缺点：查找是 O(n)，10,000 shapes 时每次查找 ~50ms
   - 成本：低开发成本，高运行时成本

2. **`shapes: Map<ShapeId, Shape>`** ⭐
   - 优点：查找 O(1)，性能稳定
   - 缺点：序列化需要手动转换
   - 成本：中等开发成本，低运行时成本

3. **`shapes: Record<string, Shape>`**
   - 优点：查找 O(1)，序列化简单
   - 缺点：无法保证类型安全（key 可能不是 ShapeId）
   - 成本：低开发成本，中等维护成本

**决策理由**：
- 查找性能是关键路径（每帧多次查找）
- 序列化复杂度可接受（`Object.fromEntries(map)`）
- TypeScript 类型安全优于序列化便利性

**后果**：
- ✅ 查找性能 O(1)，与数据规模无关
- ❌ 需要手动序列化：`toJSON()` / `fromJSON()`
- ❌ 调试时 Map 内容不可见（需要 dev tools）
- ⚠️ 风险：团队成员可能忘记序列化 Map，导致数据丢失

**合规性**：
- [x] 代码审查：检查所有序列化函数正确处理 Map
- [x] 单元测试：序列化往返测试通过
- [x] 性能基准：10,000 shapes 查找 < 1ms

**相关文档**：
- 设计方法论：阶段 4（类型架构）
- 序列化设计：阶段 5
- 实现 PR：#123
```

**估计工作量**：2-3 小时（模板 + 3-5 个示例 ADR）

---

## 🟡 中优先级改进（提升团队效率）

### 4. 增加"决策矩阵"工具化

**目标**：提供可交互的决策矩阵，帮助团队快速做技术选型

**实施方式**：

创建一个独立的 Markdown 文件 `docs/DECISION_MATRICES.md`，包含：

- 数据结构选择矩阵（Array vs Map vs Set）
- 错误处理选择矩阵（throw vs Result vs Option）
- 同步策略选择矩阵（WebSocket vs HTTP Polling vs WebRTC）
- 状态管理选择矩阵（Redux vs Zustand vs Valtio）
- CRDT 库选择矩阵（Yjs vs Automerge vs自实现）

**格式**：

```markdown
## 数据结构选择矩阵

| 场景 | Array | Map | Set | Record | 推荐 | 理由 |
|------|-------|-----|-----|--------|------|------|
| 需要 O(1) ID 查找 | ❌ O(n) | ✅ O(1) | ❌ 无值 | ✅ O(1) | **Map** | 类型安全 > 序列化便利 |
| 需要保持顺序 | ✅ | ❌ 插入序 | ❌ 无序 | ❌ 无序 | **Array** | 唯一保证顺序的结构 |
| 需要去重 | ❌ 手动 | ❌ key去重 | ✅ 自动 | ❌ key去重 | **Set** | 自动去重 + O(1)查找 |
| 需要 JSON 序列化 | ✅ 直接 | ❌ 转换 | ❌ 转换 | ✅ 直接 | **Array/Record** | 看是否需要 O(1)查找 |
| 大规模数据（10k+） | ❌ 慢 | ✅ 快 | ✅ 快 | ✅ 快 | **Map/Set/Record** | Array 迭代成本高 |
```

**估计工作量**：3-4 小时

---

### 5. 增加"性能基准数据库"

**目标**：提供真实的性能数据，而非"大概"估算

**实施方式**：

创建 `docs/PERFORMANCE_BENCHMARKS.md`，包含：

- 各种操作的实测数据（基于实际硬件）
- 不同规模下的性能曲线图
- 性能退化的临界点（100 shapes vs 1,000 vs 10,000）

**示例**：

```markdown
## 性能基准数据（MacBook Pro M1, 16GB RAM）

### 基础操作

| 操作 | 10 shapes | 100 shapes | 1,000 shapes | 10,000 shapes | 复杂度 |
|------|-----------|------------|--------------|---------------|--------|
| Map.get(id) | < 0.01ms | < 0.01ms | < 0.01ms | < 0.01ms | O(1) |
| Array.find(id) | 0.02ms | 0.15ms | 1.2ms | 12ms | O(n) |
| computeAABB() | 0.05ms | 0.3ms | 2.5ms | 25ms | O(n) |
| spatialIndex.query() | 0.1ms | 0.2ms | 0.5ms | 1.5ms | O(log n + k) |

### 序列化

| 操作 | 10 shapes | 100 shapes | 1,000 shapes | 10,000 shapes |
|------|-----------|------------|--------------|---------------|
| toJSON() | 0.5ms | 3ms | 25ms | 250ms |
| fromJSON() | 1ms | 8ms | 70ms | 700ms |

### 临界点分析

- **100 shapes**: Array.find 开始变慢（0.15ms），但仍可接受
- **1,000 shapes**: 必须使用 Map（Array.find 1.2ms，超过预算）
- **10,000 shapes**: 必须使用空间索引（否则视口查询 > 16ms）

### 内存占用

| 数据结构 | 10 shapes | 100 shapes | 1,000 shapes | 10,000 shapes |
|----------|-----------|------------|--------------|---------------|
| Array<Shape> | ~5KB | ~50KB | ~500KB | ~5MB |
| Map<ShapeId, Shape> | ~6KB | ~60KB | ~600KB | ~6MB |
| R-tree Index | ~2KB | ~20KB | ~200KB | ~2MB |

**结论**：Map 的内存开销约为 Array 的 1.2x，但换来 O(1) 查找，是值得的。
```

**估计工作量**：4-6 小时（需要实际跑 benchmark）

---

### 6. 增加"案例研究"章节

**目标**：通过真实案例展示方法论的应用

**实施方式**：

在文档末尾增加"案例研究"章节，包含 2-3 个完整的设计过程：

- 案例 1：设计 Document 类型（从零到完整实现）
- 案例 2：重构 Group 系统（从有问题的设计到正确设计）
- 案例 3：添加协作功能（冲突解决实战）

**格式**：

```markdown
## 案例研究 1：设计 Document 类型

### 初始需求

用户希望在白板上放置 shapes, groups, bindings, comments。

### 步骤 1：领域建模（15分钟）

[画出的 ERD 图]

发现：
- ✅ Shape 和 Group 是 1:N 关系
- ✅ Binding 连接两个 Shape
- ⚠️ 问题：Group 能嵌套吗？→ 决定不支持（简化实现）

### 步骤 2：数据流设计（30分钟）

[选择 3 个关键场景画数据流图]

场景 1：创建 Shape
场景 2：将 Shape 加入 Group
场景 3：删除 Shape（级联删除 Binding）

发现：
- ⚠️ 删除 Shape 时需要清理多个地方（Bindings, Group.memberIds, 索引）
- ✅ 引入 `getAffectedBindings()` 工具函数

### 步骤 2.5：冲突解决（20分钟）

决策：
- 单值属性（x, y, fill）→ LWW + HLC
- Set 操作（memberIds）→ CRDT OR-Set
- 删除操作 → Tombstone

### 步骤 3：状态机设计

[跳过，Group 的状态机已经设计过]

### 步骤 4：类型定义（1小时）

\```typescript
interface Document {
  id: DocumentId
  version: number
  shapes: Map<ShapeId, Shape>
  groups: Map<GroupId, Group>
  bindings: Map<BindingId, Binding>
  // ...
}
\```

发现：
- ⚠️ 需要 spatialIndex 来加速视口查询
- ✅ 索引标注为"可重建"，不序列化

### 步骤 5：序列化设计（30分钟）

\```typescript
interface SerializedDocument {
  schemaVersion: number
  documentVersion: number
  shapes: Record<string, Shape>
  groups: Record<string, SerializedGroup>
  // ...
}
\```

### 步骤 6：性能分析（30分钟）

[列出查询表格，决定必需的索引]

### 步骤 7：评审

发现问题：
- ❌ 忘记考虑 Comment
- ❌ spatialIndex 没有定义更新策略
- ✅ 修复后再次评审

### 步骤 8：测试策略

[编写单元测试、集成测试、E2E 测试]

### 最终设计

[完整的类型定义 + ADR]

### 经验教训

- ✅ 画图阶段发现了 Group 嵌套问题，避免了后期重构
- ✅ 数据流设计暴露了级联删除的复杂性
- ❌ 第一次评审漏掉了 Comment，浪费了 1 小时
- 💡 下次：在 Step 1 就列出所有实体类型
```

**估计工作量**：6-8 小时

---

## 🟢 低优先级改进（锦上添花）

### 7. 可视化工具矩阵扩展

**目标**：增加更多工具的对比和推荐

**内容**：
- 增加 AI 辅助工具（v0.dev, Cursor）
- 增加协作白板工具（Miro, FigJam, tldraw）
- 增加代码生成工具（TypeScript Compiler API, ts-morph）

**估计工作量**：1-2 小时

---

### 8. 增加"快速参考卡"

**目标**：提供一页纸的快速参考

**实施方式**：

创建 `docs/QUICK_REFERENCE.md`，包含：

- 设计流程的简化版（一页纸）
- 关键决策的速查表
- 常见陷阱的快速检查

**格式**：

```markdown
# 设计方法论快速参考卡

## 🚀 5 分钟版流程

1. **画 ERD**（5min）→ 理清实体和关系
2. **列场景**（10min）→ 写 5 个核心操作步骤
3. **选数据结构**（5min）→ Array? Map? Set?
4. **定义类型**（30min）→ 写 interface
5. **测试场景**（10min）→ 用类型"执行"场景

## ⚡ 关键决策速查

| 问题 | 选项 A | 选项 B | 推荐 |
|------|--------|--------|------|
| 查找频繁？ | Array | Map | **Map** |
| 需要序列化？ | Map | Record | **Record** (除非需类型安全) |
| 错误处理？ | throw | Result<T, E> | **Result** (用户错误), throw (不变量) |
| 冲突解决？ | LWW | CRDT | **LWW** (简单), CRDT (复杂) |

## 🚨 常见陷阱速查

- ❌ 对象引用代替 ID
- ❌ 临时状态进 Document
- ❌ undefined 代替 null
- ❌ 所有错误都 throw
- ❌ 忘记索引维护

## 📋 评审检查清单（精简版）

- [ ] 每个实体有 ID？
- [ ] 引用关系已标注？
- [ ] 级联删除已定义？
- [ ] Map/Set 已转换？
- [ ] 有 schemaVersion？
- [ ] 单元测试 > 80%？
```

**估计工作量**：1-2 小时

---

### 9. 多语言版本

**目标**：提供英文版文档，扩大受众

**实施方式**：
- 创建 `docs/DESIGN_METHODOLOGY_EN.md`
- 使用 AI 辅助翻译 + 人工审校

**估计工作量**：4-6 小时

---

## 📊 优先级总结

| 改进项 | 优先级 | 影响 | 工作量 | 建议时间 |
|--------|--------|------|--------|----------|
| 1. 反模式章节 | 🔴 高 | 减少返工 | 3-4h | 第1周 |
| 2. 检查清单汇总 | 🔴 高 | 提高评审质量 | 1-2h | 第1周 |
| 3. ADR 模板 | 🔴 高 | 决策可追溯 | 2-3h | 第1周 |
| 4. 决策矩阵工具化 | 🟡 中 | 加速选型 | 3-4h | 第2周 |
| 5. 性能基准数据库 | 🟡 中 | 数据驱动决策 | 4-6h | 第2-3周 |
| 6. 案例研究 | 🟡 中 | 实战示范 | 6-8h | 第3-4周 |
| 7. 工具矩阵扩展 | 🟢 低 | 锦上添花 | 1-2h | 有空时 |
| 8. 快速参考卡 | 🟢 低 | 提高可用性 | 1-2h | 有空时 |
| 9. 英文版 | 🟢 低 | 扩大受众 | 4-6h | 长期 |

**总工作量估算**：25-37 小时

**建议执行顺序**：

1. **第1周**（6-9h）：完成所有高优先级（1-3）
2. **第2周**（3-4h）：决策矩阵工具化（4）
3. **第3-4周**（10-14h）：性能基准 + 案例研究（5-6）
4. **长期**（6-10h）：低优先级项目（7-9）

---

## 🎯 立即可行的快速改进（1小时内）

如果只有 1 小时，优先做这些：

1. **汇总检查清单**（30min）→ 立即提升评审质量
2. **添加 3 个常见陷阱示例**（30min）→ 防止最常见错误

---

## 📝 维护计划

- **每季度**：更新性能基准数据（硬件变化）
- **每次重大设计后**：添加新的案例研究
- **每个月**：收集团队反馈，更新常见陷阱

---

**最后更新**：2025-12-23
**维护者**：@mind-fuse/core-team
**反馈**：提交 Issue 到 GitHub 或在团队会议上讨论
